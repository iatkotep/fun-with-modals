import { Meta } from '@storybook/blocks';

<Meta title="Modal" />
<style>
  {`
    .subheading {
      --mediumdark: '#999999';
      font-weight: 700;
      font-size: 13px;
      color: #999;
      letter-spacing: 6px;
      line-height: 24px;
      text-transform: uppercase;
      margin-bottom: 12px;
      margin-top: 40px;
    }

    .link-list {
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 1fr;
      row-gap: 10px;
    }

    @media (min-width: 620px) {
      .link-list {
        row-gap: 20px;
        column-gap: 20px;
        grid-template-columns: 1fr 1fr;
      }
    }

    @media all and (-ms-high-contrast:none) {
    .link-list {
        display: -ms-grid;
        -ms-grid-columns: 1fr 1fr;
        -ms-grid-rows: 1fr 1fr;
      }
    }

    .link-item {
      display: block;
      padding: 20px;
      border: 1px solid #00000010;
      border-radius: 5px;
      transition: background 150ms ease-out, border 150ms ease-out, transform 150ms ease-out;
      color: #333333;
      display: flex;
      align-items: flex-start;
    }

    .link-item:hover {
      border-color: #1EA7FD50;
      transform: translate3d(0, -3px, 0);
      box-shadow: rgba(0, 0, 0, 0.08) 0 3px 10px 0;
    }

    .link-item:active {
      border-color: #1EA7FD;
      transform: translate3d(0, 0, 0);
    }

    .link-item strong {
      font-weight: 700;
      display: block;
      margin-bottom: 2px;
    }

    .link-item img {
      height: 40px;
      width: 40px;
      margin-right: 15px;
      flex: none;
    }

    .link-item span,
    .link-item p {
      margin: 0;
      font-size: 14px;
      line-height: 20px;
    }

    .tip {
      display: inline-block;
      border-radius: 1em;
      font-size: 11px;
      line-height: 12px;
      font-weight: 700;
      background: #E7FDD8;
      color: #66BF3C;
      padding: 4px 12px;
      margin-right: 10px;
      vertical-align: top;
    }

    .tip-wrapper {
      font-size: 13px;
      line-height: 20px;
      margin-top: 40px;
      margin-bottom: 40px;
    }

    .tip-wrapper code {
      font-size: 12px;
      display: inline-block;
    }

    pre, code {
      font-weight: bold;
    }
  `}
</style>

# Notes

### Mention-worthy

Built with **Chakra UI**. I think it does a great job of providing css-in-js functionality without all the boilerplate you get from Styled Components.  It also has a very well wrought and flexible styling system that very effectively abstracts style rules away from component logic.

I'm using event delegation to handle Modal Behavior.  It felt like the natural way to go, since I was dealing with an abundance of elements triggering a small number of events. It was lighter weight and more extensible than having to bury callbacks into every element that needed to either close or confirm (or both!) the modal.

Rendering Modal at the top of the Dom tree using a React Portal.


# Things I don't like
#### Documentation
Using Storybook for everything for this presentation.  It's a nice compromise between development, testing, and documentation. Would prefer a fleshed out README.md and jsDoc comments in the code.

***

#### Jest tests
Omitted for lack of time.  I have a patterned way of streamlining my stories and tests, which I have done here.  I've put myself in a place where Jest tests will be easy to write.

***

#### No Modal analytics support
state changes in the modal prevent native button events from firing.  What I have meets requirements of the Spec, but would have preferred to have an additional layer of functionality

***

#### Modal Forms
Another issue with Modal State management.  Including a Modal Body that managed its own state was creating rerender issues.  I didn't have time to dig into what and when to memoize.

***

#### No Scroll Blocking
It feels natural for a modal to block scrolling functionality while open.  I was not comfortable introducing that here. Since each Modal manages its own state, it would be up to each Modal to disable the scrollbar.  That presents a jurisdiction conflict.  I believe that the scrollbar belongs to the App.

***

#### Using css classes to trigger Modal behavior
My event delegate uses css classes to determine if something important has been clicked. This was for convenience. In practice, I don't think css classes are the right tool for this job.

***

#### Method for conditional Cancel renderiong
Supplying button text as a mechanism for conditional rendering feels a little unnatural.  In a real-life scenario, I would prefer a more ergonomic interface.

***

#### Messy JSX
My preference is to define props in an object literal, and then spread them into a JSX element.  This results in very terse and digestible view markup, and allows me to lift the props out of the JSX, and rehome them if needed into a props.ts file.  Sometimes I will use html-style attribute props, but I try to be consistent.  How I handle props for any component is unique to that component, and evolves throughout the development process.  The JSX is messy right now, and needs to be tidied up.

***

#### No style handling for "too many buttons"
I wanted a scrolling overflow, with a maxheight on the mobile view, but I was encountering styling issues while trying to implement.

***

#### Hooks are difficult to test
You can't just test what you've made like a component, you have to write a new component to pull the hook in.  Adds overhead.
