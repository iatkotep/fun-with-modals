import { Meta } from '@storybook/blocks';

<Meta title="Modal" />
<style>
  {`
    .subheading {
      --mediumdark: '#999999';
      font-weight: 700;
      font-size: 13px;
      color: #999;
      letter-spacing: 6px;
      line-height: 24px;
      text-transform: uppercase;
      margin-bottom: 12px;
      margin-top: 40px;
    }

    .link-list {
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 1fr;
      row-gap: 10px;
    }

    @media (min-width: 620px) {
      .link-list {
        row-gap: 20px;
        column-gap: 20px;
        grid-template-columns: 1fr 1fr;
      }
    }

    @media all and (-ms-high-contrast:none) {
    .link-list {
        display: -ms-grid;
        -ms-grid-columns: 1fr 1fr;
        -ms-grid-rows: 1fr 1fr;
      }
    }

    .link-item {
      display: block;
      padding: 20px;
      border: 1px solid #00000010;
      border-radius: 5px;
      transition: background 150ms ease-out, border 150ms ease-out, transform 150ms ease-out;
      color: #333333;
      display: flex;
      align-items: flex-start;
    }

    .link-item:hover {
      border-color: #1EA7FD50;
      transform: translate3d(0, -3px, 0);
      box-shadow: rgba(0, 0, 0, 0.08) 0 3px 10px 0;
    }

    .link-item:active {
      border-color: #1EA7FD;
      transform: translate3d(0, 0, 0);
    }

    .link-item strong {
      font-weight: 700;
      display: block;
      margin-bottom: 2px;
    }

    .link-item img {
      height: 40px;
      width: 40px;
      margin-right: 15px;
      flex: none;
    }

    .link-item span,
    .link-item p {
      margin: 0;
      font-size: 14px;
      line-height: 20px;
    }

    .tip {
      display: inline-block;
      border-radius: 1em;
      font-size: 11px;
      line-height: 12px;
      font-weight: 700;
      background: #E7FDD8;
      color: #66BF3C;
      padding: 4px 12px;
      margin-right: 10px;
      vertical-align: top;
    }

    .tip-wrapper {
      font-size: 13px;
      line-height: 20px;
      margin-top: 40px;
      margin-bottom: 40px;
    }

    .tip-wrapper code {
      font-size: 12px;
      display: inline-block;
    }

    pre, code {
      font-weight: bold;
    }
  `}
</style>

# W
orthy of Note

Built with **Chakra UI**. I think it does a great job of providing css-in-js functionality without all the boilerplate you get from Styled Components.  It also has a very well wrought and flexible styling system that very effectively abstracts style rules away from component logic.

I'm using event delegation to handle Modal Behavior.  It felt like the natural way to go, since I was dealing with an abundance of elements triggering a small number of events. It was lighter weight and more extensible than having to bury callbacks into every element that needed to either close or confirm (or both!) the modal.

Rendering Modal at the top of the Dom tree using a React Portal.


# Things I don't like
- Documentation -  Using Storybook for everything for this presentation.  It's a nice compromise between development, testing, and documentation. Would prefer a fleshed out README.md and jsDoc comments in the code.
- Jest tests - Omitted for lack of time.  I have a patterned way of streamlining my stories and tests, which I have done here.  I've put myself in a place where Jest tests will be easy to write.
- Modal analytics support - state changes in the modal prevent native button events from firing.  What I have meets requirements of the Spec, but would have preferred to have an additional layer of functionality
- Modal Forms - Another issue with Modal State management.  Including a Modal Body that managed its own state was creating rerender issues.  I didn't have time to dig into what and when to memoize.
- Scroll Blocking - It feels natural for a modal to block scrolling functionality while open.  I was not comfortable introducing that, since each Modal manages its own state. it didn't feel right to give the Modal that level of control over the page.  I could see that causing all kinds of problems down the road.  Scroll Blocking would have been appropriate if I had a global system for managing Modal state, and an observer that could keep an eye on that state, and block the scrollbar whenever a modal opened.
- using css classes to trigger Modal behavior.  event delegate detects the classes present on a clicked element, and intersects with an allowList. This was for convenience, in practice, I don't think css classes are the right tool for this job.
- The way I'm handling conditional rendering of the Cancel button feels a little unnatural.  In a real-life scenario, I would prefer a more ergonomic interface.
- JSX markup is not as lean as I'd like.  My preference is to define props in a separate object, and then spread them into the component.  This is a little more verbose, but I think it makes the code more digestible. What I have presented here is a mix of spread props and html-style attributes.  I would prefer to be consistent.
- No graceful degradation styles for a modal with too many buttons.  I wanted a scrolling overflow, but I was encountering styling issues while trying to implement.
- hooks are difficult to test.  You can't just test what you've made like a component, you have to write a new component to pull the hook in.  Adds overhead.
yarn
